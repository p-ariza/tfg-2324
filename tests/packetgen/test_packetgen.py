#!/usr/bin/env python

import os
import re

# import pytest
# import cocotb_test.simulator

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import Timer

from cocotbext.axi import AxiStreamBus, AxiStreamSink, AxiStreamFrame

def split_int_parameter(parameter, value_size, n_flows):
    full_parameter = re.search(r"[bh]([0-9a-fA-F]+)", os.environ.get(parameter)).group(1)
    values = [None] * n_flows
    for f in range(n_flows):
        values[f] = int(full_parameter[f*value_size:(f+1)*value_size], 2)
    return values

def split_string_parameter(parameter, value_size, n_flows):
    full_parameter = re.search(r"[bh]([0-9a-fA-F]+)", os.environ.get(parameter)).group(1)
    values = [None] * n_flows
    for f in range(n_flows):
        values[f] = full_parameter[f*value_size:(f+1)*value_size]
    return values

@cocotb.test()
async def run_frame_content_test(dut):
    """
    Checking frame contents
    """
    #DUT Parameters
    n_flows = int(os.environ.get("PARAM_N_FLOWS"))
   
    
    print(os.environ.get("PARAM_SIZES"))

    sizes = split_int_parameter("PARAM_SIZES",11,n_flows)
    print(sizes)
    bandwidths = split_int_parameter("PARAM_BANDWIDTHS",32,n_flows)
    d_macs = split_string_parameter("PARAM_D_MACS",12,n_flows)
    s_macs = split_string_parameter("PARAM_S_MACS",12,n_flows)
    ethertypes = split_string_parameter("PARAM_ETHERTYPES",4,n_flows)
    payloads = split_string_parameter("PARAM_PAYLOADS",2,n_flows)

    # Create frames
    axi_frames = [None] * n_flows
    for f in range(n_flows):
        axi_frames[f] = AxiStreamFrame(bytearray.fromhex(d_macs[f] + s_macs[f] + ethertypes[f] + payloads[f]*(sizes[f]-14)), [1]*sizes[f]).tdata
        print(len(axi_frames[f]))

    #AxiStream Sink
    axis_sink = AxiStreamSink(AxiStreamBus.from_prefix(dut, "axis"), dut.clk, dut.rst)
    
    #Start clock
    cocotb.start_soon(Clock(dut.clk, 3, units="ns").start())

    # Reset DUT
    dut.rst.value = 1
    await Timer(1, units="ns")
    dut.rst.value = 0

    # Check 100 frames' content
    for _ in range(100):
        recv_frame = await axis_sink.recv(compact=True)
        recv_frame.tid = recv_frame.tdest = recv_frame.tuser = recv_frame.sim_time_start = recv_frame.sim_time_end = None
        assert recv_frame.tdata in axi_frames

@cocotb.test()
async def run_bandwidth_test(dut):
    """
    Testing bandwidth generated by the DUT
    """

    #DUT Parameters
    frequency = dut.FREQUENCY.value
    n_flows = int(os.environ.get("PARAM_N_FLOWS"))

    sizes = split_int_parameter("PARAM_SIZES",11,n_flows)
    bandwidths = split_int_parameter("PARAM_BANDWIDTHS",32,n_flows)
    bandwidths = [bw * pow(10,3) for bw in bandwidths]
    d_macs = split_string_parameter("PARAM_D_MACS",12,n_flows)
    s_macs = split_string_parameter("PARAM_S_MACS",12,n_flows)
    ethertypes = split_string_parameter("PARAM_ETHERTYPES",4,n_flows)
    payloads = split_string_parameter("PARAM_PAYLOADS",2,n_flows)


    # Create frames
    axi_frames = [None] * n_flows
    for f in range(n_flows):
        axi_frames[f] = AxiStreamFrame(bytearray.fromhex(d_macs[f] + s_macs[f] + ethertypes[f] + payloads[f]*(sizes[f]-14)), [1]*sizes[f])

    period = round(1/(frequency/pow(10,6)),3)

    dut._log.info("Clock period: %f", period)

    #AxiStream Sink
    axis_sink = AxiStreamSink(AxiStreamBus.from_prefix(dut, "axis"), dut.clk, dut.rst)

    #Start clock
    cocotb.start_soon(Clock(dut.clk, period, units="ns").start())

    # Reset DUT
    dut.rst.value = 1
    await Timer(1, units="ns")
    dut.rst.value = 0

    byte_counts = [0] * n_flows
    start_ns = cocotb.utils.get_sim_time(units="ns")
    for _ in range(1000):
        recv_frame = await axis_sink.recv()
        for i, frame in enumerate(axi_frames):
            if(recv_frame == frame):
                byte_counts[i] += len(recv_frame.tdata)

    end_ns = cocotb.utils.get_sim_time(units="ns")

    for count in byte_counts:
        count = count

    elapsed_time_ns = end_ns - start_ns
    dut._log.info("Elapsed time: %d - %d = %d", end_ns, start_ns, elapsed_time_ns)
    # Output bandwidths in bits/s
    out_bws = [(count*8/elapsed_time_ns)*pow(10,9) for count in byte_counts]

    error_range = 0.01
    for flow, bw in enumerate(out_bws):
        assert bandwidths[flow]*(1-error_range) < bw
        assert bandwidths[flow]*(1+error_range) > bw
